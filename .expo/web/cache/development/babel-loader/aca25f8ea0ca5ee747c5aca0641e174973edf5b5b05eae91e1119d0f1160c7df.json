{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport jwt from \"jsonwebtoken\";\nimport { prisma } from \"../database/prisma\";\nimport bcrypt from \"bcrypt\";\nvar saltRounds = 10;\nexport var criarUsuario = function () {\n  var _ref = _asyncToGenerator(function* (req, res) {\n    var _ref2 = req.body || {},\n      email = _ref2.email,\n      password = _ref2.password,\n      fullName = _ref2.fullName,\n      birthDate = _ref2.birthDate,\n      type = _ref2.type,\n      Role = _ref2.Role;\n    try {\n      var existingUser = yield prisma.user.findUnique({\n        where: {\n          email: email\n        },\n        select: {\n          email: true\n        }\n      });\n      if (existingUser) {\n        return res.status(400).json({\n          success: false,\n          message: \"Usuário já existe.\"\n        });\n      }\n      var hash = yield bcrypt.hash(password, saltRounds);\n      var _fullName$split = fullName.split(\" \"),\n        _fullName$split2 = _slicedToArray(_fullName$split, 3),\n        firstName = _fullName$split2[0],\n        middleName = _fullName$split2[1],\n        lastName = _fullName$split2[2];\n      console.log(\"birthDate antes:\", birthDate);\n      var user = yield prisma.user.create({\n        data: {\n          email: email,\n          password: hash,\n          firstName: firstName,\n          middleName: middleName,\n          lastName: lastName,\n          birthDate: new Date(birthDate).toISOString(),\n          type: type || Role.User\n        }\n      });\n      console.log(\"Usuário criado:\", user);\n      res.status(201).json(user);\n    } catch (err) {\n      console.error(err);\n      res.status(400).json({\n        success: false,\n        message: \"Erro ao criar usuário.\"\n      });\n    } finally {\n      yield prisma.$disconnect();\n    }\n  });\n  return function criarUsuario(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var fazerLogin = function () {\n  var _ref3 = _asyncToGenerator(function* (req, res) {\n    var _ref4 = req.body || {},\n      email = _ref4.email,\n      password = _ref4.password;\n    try {\n      var login = yield prisma.user.findUnique({\n        where: {\n          email: email\n        },\n        select: {\n          email: true,\n          password: true,\n          type: true\n        }\n      });\n      var match = yield bcrypt.compare(password, String(login == null ? void 0 : login.password));\n      if (!login || !match) {\n        return res.status(400).json({\n          success: false,\n          message: \"Usuário não encontrado ou senha incorreta.\"\n        });\n      }\n      var token = jwt.sign({\n        email: email,\n        type: login == null ? void 0 : login.type\n      }, \"senha_secreta\");\n      res.status(200).json({\n        jwt: `Bearer ${token}`\n      });\n    } catch (err) {\n      return res.status(400).json({\n        success: false,\n        message: \"Usuário incorreto.\"\n      });\n    } finally {\n      yield prisma.$disconnect();\n    }\n  });\n  return function fazerLogin(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar userController = {\n  criarUsuario: criarUsuario,\n  fazerLogin: fazerLogin\n};\nexport default userController;","map":{"version":3,"names":["jwt","prisma","bcrypt","saltRounds","criarUsuario","_ref","_asyncToGenerator","req","res","_ref2","body","email","password","fullName","birthDate","type","Role","existingUser","user","findUnique","where","select","status","json","success","message","hash","_fullName$split","split","_fullName$split2","_slicedToArray","firstName","middleName","lastName","console","log","create","data","Date","toISOString","User","err","error","$disconnect","_x","_x2","apply","arguments","fazerLogin","_ref3","_ref4","login","match","compare","String","token","sign","_x3","_x4","userController"],"sources":["C:/Users/digoR/OneDrive/Área de Trabalho/DEV/Sollos/Deploy/VistoApp_Backend/src/controller/userController.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"../database/prisma\";\r\nimport { Request, Response } from \"express\";\r\nimport bcrypt from \"bcrypt\";\r\n\r\nconst saltRounds = 10;\r\n\r\nexport const criarUsuario = async (req: Request, res: Response) => {\r\n  const { email, password, fullName, birthDate, type, Role } = req.body || {};\r\n\r\n  try {\r\n    // Verifica se o usuário já existe\r\n    const existingUser = await prisma.user.findUnique({\r\n      where: { email },\r\n      select: { email: true },\r\n    });\r\n\r\n    if (existingUser) {\r\n      return res\r\n        .status(400)\r\n        .json({ success: false, message: \"Usuário já existe.\" });\r\n    }\r\n\r\n    // Gera o hash da senha\r\n    const hash = await bcrypt.hash(password, saltRounds);\r\n\r\n    // Divide o nome completo em partes\r\n    const [firstName, middleName, lastName] = fullName.split(\" \");\r\n\r\n    console.log(\"birthDate antes:\", birthDate);\r\n\r\n    // Cria o usuário no banco de dados\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email,\r\n        password: hash,\r\n        firstName,\r\n        middleName,\r\n        lastName,\r\n        birthDate: new Date(birthDate).toISOString(),\r\n        type: type || Role.User,\r\n      },\r\n    });\r\n\r\n    console.log(\"Usuário criado:\", user);\r\n\r\n    res.status(201).json(user);\r\n  } catch (err) {\r\n    console.error(err);\r\n    res.status(400).json({ success: false, message: \"Erro ao criar usuário.\" });\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n};\r\n\r\nexport const fazerLogin = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body || {};\r\n\r\n  try {\r\n    // Busca o usuário no banco de dados\r\n    const login = await prisma.user.findUnique({\r\n      where: { email },\r\n      select: { email: true, password: true, type: true },\r\n    });\r\n\r\n    // Compara as senhas\r\n    const match = await bcrypt.compare(password, String(login?.password));\r\n\r\n    if (!login || !match) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: \"Usuário não encontrado ou senha incorreta.\",\r\n      });\r\n    }\r\n\r\n    // Gera o token JWT\r\n    const token = jwt.sign({ email, type: login?.type }, \"senha_secreta\");\r\n\r\n    res.status(200).json({ jwt: `Bearer ${token}` });\r\n  } catch (err) {\r\n    return res\r\n      .status(400)\r\n      .json({ success: false, message: \"Usuário incorreto.\" });\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n};\r\n\r\nconst userController = {\r\n  criarUsuario,\r\n  fazerLogin,\r\n};\r\n\r\nexport default userController;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}